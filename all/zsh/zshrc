export LC=en_US.UTF-8;
export LC_CTYPE=en_US.UTF-8;
export LC_ALL=en_US.UTF-8;
export LANG=en_US.UTF-8;
export EDITOR='nvim';

_uname=$(uname);
[[ $_uname == "Linux" ]] && is_linux=true || is_linux=false;
[[ $_uname == "Darwin" ]] && is_darwin=true || is_darwin=false;
[[ $(hostname) == "vsvetlov-rog" ]] && is_wsl_host=true || is_wsl_host=false;

export HOME=$(cd ${HOME}; pwd -P);
export WORKSPACE="${HOME}/workspace"

if [[ -d "${WORKSPACE}/.local" ]]; then
  export HOMEDIR=${WORKSPACE};
else
  export HOMEDIR=${HOME};
fi

export LOCAL=${HOMEDIR}/.local;
if [[ $is_darwin == true ]]; then
  export LOCAL_OS_SPECIFIC=${HOMEDIR}/.local.mac
elif [[ $is_linux == true ]]; then
  export OSNAME=$(lsb_release -is);
  if [[ "${OSNAME}" == "CentOS" ]]; then
    export LOCAL_OS_SPECIFIC=${HOMEDIR}/.local.centos
  elif [[ "${OSNAME}" == "Ubuntu" ]]; then
    export LOCAL_OS_SPECIFIC=${HOMEDIR}/.local.ubuntu
  fi
fi

export WORKON_HOME=${HOMEDIR}/.virtualenvs;
export PROJECT_HOME=${HOMEDIR}/projects;
export DOTS_HOME=${PROJECT_HOME}/dots;

export IPYTHON_PORT=6500;
export VIRTUALENVWRAPPER_PYTHON=python3;

export LUA_VERSION="5.3";
export TMUX_VERSION="2.5";

# Regular Colors
export COLOR_OFF=$'\e[0m'             # Text Reset
export COLOR_BLACK=$'\e[0;30m'        # Black
export COLOR_RED=$'\e[0;31m'          # Red
export COLOR_GREEN=$'\e[0;32m'        # Green
export COLOR_YELLOW=$'\e[0;33m'       # Yellow
export COLOR_BLUE=$'\e[0;34m'         # Blue
export COLOR_PURPLE=$'\e[0;35m'       # Purple
export COLOR_CYAN=$'\e[0;36m'         # Cyan
export COLOR_WHITE=$'\e[0;37m'        # White


alias editor="nvim"
alias vim='nvim'
alias zshconfig="nvim ~/.zshrc"
alias vimlarge="nvim -u NONE -U NONE -N"
alias vimconfig="nvim ~/.config/nvim/init.lua"
alias vimplugins="nvim ~/.config/nvim/lua/plugins/core.lua"
alias ohmyzsh="nvim ~/.oh-my-zsh"
alias cx="chmod +x "
alias rm="rm -i"
alias mv="mv -i"
alias wgetn="wget --no-check-certificate";
alias ipython='ipython --TerminalInteractiveShell.editing_mode=vi'
alias tensorboard="CUDA_VISIBLE_DEVICES= tensorboard";


reset-ssh() {
    sudo netstat -apn | grep -w 2224 | awk '{ print $7 }' | sed 's/\(.*\)\/.*/\1/' | sort -u | xargs -I{} kill -9 {};
}

_pathstr_contains() {
    # check $2 is a subpart of pathes of $1
    splitted=$( echo $1 | tr ":" "\n" );
    echo ${splitted[@]} | grep -q -w -E "^$2$" > /dev/null;
    [[ $? -eq 0 ]] && return 1 || return 0;
}

_safe_symlink() {
    if [[ -f "$2" ]]; then  # destination exists
        if [[ -L "$2" ]]; then   # destination is symlink
            local realDstPath=$(readlink -f "$2");
            if [[ "${realDstPath}" == "$1" ]]; then  # destination is linked to source
                echo "Destination file '$2' already exists and points to source '$1'" 1>&2;
                return;
            elif [[ ! -f "${realDstPath}" ]]; then  # destination is broken symlink
                rm "$2";
            else  # desitnation is link
                if [[ -f "${2}.back" ]]; then  # back file exits, failing
                    echo "Destination file '$2' already exists, and .back file also already exists" 1>&2;
                    return;
                fi
                echo "Making backup for existing destination file '$2'" 1>&2;
                ln -s ${realDstPath} "$2.back"
            fi
        elif [[ "${realDstPath}" == "$2" ]]; then  # destination exists and it's regular file
            if [[ -f "${2}.back" ]]; then  # back file exits, failing
                echo "Destination file '$2' already exists, and .back file also already exists" 1>&2;
                return;
            fi
            echo "Making backup for existing destination file '$2'">&2;
            cp $2 "$2.back"
        fi
    fi

    echo "Linking source $1 to destination $2" 1>&2;
    ln -s $1 $2;
}

_smart_append() {
  if [[ "$#" -eq 2 ]]; then
    _pathstr_contains $1 $2;
    if [[ $? -eq 0  && -d $2 ]] ; then
        echo "$2:$1";  # $2 is not substring of $1 and exists
    else
        echo "$1";
    fi
  elif [[ "$#" -eq 1 ]]; then
    echo "$1";
  else
    echo "Illegal number of paramters in _smart_append function" 1>&2;
  fi
}

# =====================================================================================================================
# =============================================== Env Creator Settings ================================================
# =====================================================================================================================

_to_clean_env() {
    echo "${COLOR_RED}don't forget call 'tmux detach'${COLOR_OFF}";
    PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin";
    CPATH="/usr/local/include";
    LIBRARY_PATH="/usr/local/lib";
    LD_LIBRARY_PATH="/usr/local/lib";

    export PATH; export CPATH; export LIBRARY_PATH; export LD_LIBRARY_PATH;
}

_update_env() {
    PATH=$(_smart_append ${PATH} "${LOCAL_OS_SPECIFIC}/bin");
    PATH=$(_smart_append ${PATH} "${LOCAL}/bin");
    PATH=$(_smart_append ${PATH} "/usr/local/bin");
    PATH=$(_smart_append ${PATH} "/usr/local/opt/coreutils/libexec/gnubin");
    PATH=$(_smart_append ${PATH} "/usr/texbin");

    CPATH=$(_smart_append ${CPATH} "${LOCAL_OS_SPECIFIC}/bin");
    CPATH=$(_smart_append ${CPATH} "${LOCAL}/include");
    CPATH=$(_smart_append ${CPATH} "/usr/local/include");

    LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "${LOCAL_OS_SPECIFIC}/usr/lib");
    LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "${LOCAL_OS_SPECIFIC}/lib");
    LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "${LOCAL}/usr/lib");
    LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "${LOCAL}/lib");
    LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "/usr/local/lib");

    LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${LOCAL_OS_SPECIFIC}/usr/lib");
    LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${LOCAL_OS_SPECIFIC}/lib");
    LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${LOCAL}/usr/lib");
    LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${LOCAL}/lib");
    LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "/usr/local/lib");

    if [[ -d "/usr/local/cuda" ]]; then
        export CUDA_HOME="/usr/local/cuda";
        PATH=$(_smart_append ${PATH} "${CUDA_HOME}/bin");
        CPATH=$(_smart_append ${CPATH} "${CUDA_HOME}/include");
        LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "${CUDA_HOME}/lib64");
        LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${CUDA_HOME}/lib64");  # libcudart
        # LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${CUDA_HOME}/lib64/stubs");  # libcuda
        LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${CUDA_HOME}/extras/CUPTI/lib64");  # libcupti
    fi

    if [[ -d "/opt/openmpi" ]]; then
        export MPI_PATH="/opt/openmpi";
        export CPLUS_INCLUDE_PATH="${MPI_PATH}/include";
        PATH=$(_smart_append ${PATH} "${MPI_PATH}/bin");
        CPATH=$(_smart_append ${CPATH} "${MPI_PATH}/include");
        LIBRARY_PATH=$(_smart_append ${LIBRARY_PATH} "${MPI_PATH}/lib");
        LD_LIBRARY_PATH=$(_smart_append ${LD_LIBRARY_PATH} "${MPI_PATH}/lib");
    fi

    export PATH; export CPATH; export LIBRARY_PATH; export LD_LIBRARY_PATH; export MANPATH; export INFOPATH;
}

_update_env;

# =====================================================================================================================
# ================================================= OhMyZsh Settings ==================================================
# =====================================================================================================================

export ZSH=$HOME/.oh-my-zsh

if [[ ! -f ${ZSH}/oh-my-zsh.sh ]]; then
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

    git clone https://github.com/junegunn/fzf.git ${ZSH}/custom/plugins/fzf;
    ${ZSH}/custom/plugins/fzf/install --bin;
    git clone https://github.com/Treri/fzf-zsh.git ${ZSH}/custom/plugins/fzf-zsh;
    _update_env;

    _safe_symlink "${DOTS_HOME}/all/zsh/bashrc" "${HOME}/.bashrc"
    _safe_symlink "${DOTS_HOME}/all/zsh/zshrc" "${HOME}/.zshrc"
    _safe_symlink "${DOTS_HOME}/all/zsh/mytheme.zsh-theme" "${HOME}/.oh-my-zsh/custom/themes/mytheme.zsh-theme"
fi
export FZF_DEFAULT_COMMAND="fd --type file"

if [[ -f "${HOME}/.oh-my-zsh/custom/themes/mytheme.zsh-theme" ]]; then
    ZSH_THEME="mytheme";
else
    ZSH_THEME="maran";
fi

ENABLE_CORRECTION="false"
COMPLETION_WAITING_DOTS="true"
HIST_STAMPS="yyyy-mm-dd"

plugins=(git tmux python brew history-substring-search uv vi-mode fzf-zsh)

source ${ZSH}/oh-my-zsh.sh

# =====================================================================================================================
# ================================================= OhMyZsh Settings ==================================================
# =====================================================================================================================

export ZSH=${HOMEDIR}/.oh-my-zsh

if [[ ! -f ${ZSH}/oh-my-zsh.sh ]]; then
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

    git clone https://github.com/junegunn/fzf.git ${ZSH}/custom/plugins/fzf;
    ${ZSH}/custom/plugins/fzf/install --bin;
    git clone https://github.com/Treri/fzf-zsh.git ${ZSH}/custom/plugins/fzf-zsh;
    _update_env;

    _safe_symlink "${DOTS_HOME}/all/zsh/bashrc" "${HOME}/.bashrc"
    _safe_symlink "${DOTS_HOME}/all/zsh/zshrc" "${HOME}/.zshrc"
    _safe_symlink "${DOTS_HOME}/all/zsh/mytheme.zsh-theme" "${HOME}/.oh-my-zsh/custom/themes/mytheme.zsh-theme"
fi
export FZF_BASE=${ZSH}/custom/plugins/fzf;
# export FZF_DEFAULT_COMMAND="fd --type file"

if [[ -f "${HOMEDIR}/.oh-my-zsh/custom/themes/mytheme.zsh-theme" ]]; then
    ZSH_THEME="mytheme";
else
    ZSH_THEME="maran";
fi

export HISTFILE=${HOMEDIR}/.zsh_history;
export HISTFILESIZE=5000;
export HISTSIZE=1000;

DISABLE_AUTO_UPDATE=true
ENABLE_CORRECTION="false"
COMPLETION_WAITING_DOTS="true"
HIST_STAMPS="yyyy-mm-dd"

plugins=(git tmux python brew history-substring-search vi-mode fzf-zsh uv)

# do not forget to make zsh directories properly owned in case of compinit problmes
# chown -R $USER $ZSH_INSTALL_PREFIX/share/zsh/
# chmod -R 755 $ZSH_INSTALL_PREFIX/share/zsh/

source ${ZSH}/oh-my-zsh.sh

_ssh_agent_maybe_launch() {
  if [[ -z "$SSH_AGENT_PID" ]]; then
    if command -v keychain > /dev/null 2>&1; then
      eval $(keychain --eval --quiet --inherit any github.ed25519)
    else
      # On Ubuntu/Debian: sudo apt install keychain
      # On macOS: brew install keychain
      echo "Please install keychain command"
    fi
  fi
  _ssh_agent_attach_fixed_path
}

_ssh_agent_attach_fixed_path() {
  # Maintain symlink to socket (like Linux section does)
  if [[ -n "$SSH_AUTH_SOCK" && "$SSH_AUTH_SOCK" =~ ^/tmp/ ]]; then
    # Create symlink if it doesn't exist or points to wrong location
    if [[ ! -L ~/.ssh/ssh_auth_sock ]] || \
       [[ "$(readlink -f ~/.ssh/ssh_auth_sock)" != "$(readlink -f "$SSH_AUTH_SOCK")" ]]; then
	ln -sf "$SSH_AUTH_SOCK" ~/.ssh/ssh_auth_sock
    fi
  fi
}

# TODO FIXME
# eval "$(/home/vsvetlov/miniconda3/bin/conda shell.zsh hook)"

if [[ -f "${HOMEDIR}/.secrets.rc" ]]; then
    source "${HOMEDIR}/.secrets.rc"
fi

# =====================================================================================================================
# =============================================== OS Specific Settings ================================================
# =====================================================================================================================
if [[ $is_darwin == true || $is_wsl_host == true ]]; then
    _ssh_agent_maybe_launch;
    if [[ "${#TMUX}" -eq 0 ]]; then
        tmux attach || tmux new -A
    fi
elif [[ $is_linux == true ]]; then
    if [[ -L "${HOME}/.zshrc" ]]; then
        if [[ "${#TMUX}" -eq 0 ]]; then
	        _ssh_agent_attach_fixed_path;
            tmux attach || tmux new -A
        fi
    fi
else
    echo "${COLOR_RED}Unknown host $(uname -s)${COLOR_OFF}";
fi

